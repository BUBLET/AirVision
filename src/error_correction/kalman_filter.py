import numpy as np

class KalmanFilter:
    def __init__(self, dt, process_noise, measurement_noise):
        """
        Инициализация фильтра Калмана.

        Параметры:
        - dt (float): шаг времени между измерениями.
        - process_noise (float): уровень шума процесса, учитывающий непредсказуемые изменения в движении.
        - measurement_noise (float): уровень шума измерений, определяющий точность сенсоров.
        """
        self.dt = dt
        self.process_noise = process_noise
        self.measurement_noise = measurement_noise

        # Инициализация состояния: [x, y, vx, vy], где:
        # x, y — позиция, vx, vy — скорость по осям x и y.
        self.state = np.zeros((4, 1))

        # Модель перехода (F) определяет, как состояние изменяется со временем.
        self.F = np.array([[1, 0, self.dt, 0],  # x = x + vx * dt
                           [0, 1, 0, self.dt],  # y = y + vy * dt
                           [0, 0, 1, 0],        # vx остаётся без изменений
                           [0, 0, 0, 1]])       # vy остаётся без изменений

        # Модель наблюдений (H) позволяет фильтру Калмана извлекать позицию из состояния.
        self.H = np.array([[1, 0, 0, 0],        # Извлечение x
                           [0, 1, 0, 0]])       # Извлечение y

        # Ковариационная матрица состояния (P) — начальная неопределенность состояния.
        self.P = np.eye(4)

        # Ковариационная матрица шума процесса (Q) — учёт неидеальности модели и внешних воздействий.
        self.Q = np.eye(4) * self.process_noise

        # Ковариационная матрица шума измерений (R) — уровень шума в данных от сенсоров.
        self.R = np.eye(2) * self.measurement_noise

    def predict(self):
        """
        Шаг предсказания: прогнозирование состояния системы на следующий временной шаг.
        """
        # Обновляем состояние на основе модели перехода.
        self.state = self.F @ self.state

        # Обновляем ковариацию ошибки состояния с учетом шума процесса.
        self.P = self.F @ self.P @ self.F.T + self.Q

    def update(self, measurement):
        """
        Шаг обновления: корректировка предсказанного состояния на основе нового измерения.

        Параметры:
        - measurement (numpy.ndarray): новое измерение позиции (x, y).
        """
        # Вычисляем ошибку между измерением и предсказанным состоянием.
        y = measurement - (self.H @ self.state)

        # Вычисляем ковариацию ошибки измерения.
        S = self.H @ self.P @ self.H.T + self.R

        # Вычисляем коэффициент Калмана (весовое значение для измерения).
        K = self.P @ self.H.T @ np.linalg.inv(S)

        # Обновляем состояние с учётом новой информации.
        self.state += K @ y

        # Обновляем ковариацию, уменьшая неопределенность.
        self.P = (np.eye(4) - K @ self.H) @ self.P

    def get_position(self):
        """
        Возвращает текущую позицию (x, y) из состояния.
        
        Возвращает:
        - (numpy.ndarray): позиция в формате (x, y).
        """
        return self.state[0:2].flatten()

    def get_velocity(self):
        """
        Возвращает текущую скорость (vx, vy) из состояния.
        
        Возвращает:
        - (numpy.ndarray): скорость в формате (vx, vy).
        """
        return self.state[2:4].flatten()